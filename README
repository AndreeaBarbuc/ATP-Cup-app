	Scopul programului este de a automatiza desfasurarea "Turneului International de Tenis ATP Cup".
	Initial sunt citite datele din cele doua fisiere (din "cerinte.in" aflam daca vom afisa,rezolva cerinta corespunzatoare cifrei din fisier, iar in "date.in" sunt stocate datele initiale despre tarile participante). Astfel, mi-am creat o functie care citeste informatiile despre tari si o alta functie care le adauga la finalul unei liste dublu inlantuite (circulara si cu santinela), inserarea facandu-se in functie de pozitia pe care o trimit din main, aceasta determinand intotdeauna inserarea la final.
	Pentru ca sa nu se afiseze datele corespunzatoare primei cerinte si in cadrul celorlalte cerinte am pus o conditie. Afisarea se face cu ajutorul unei alte functii.
	In continuare, mi-am creat o functie care sa-mi calculeze cate tari vor fi elimitate din competitie (sterse). Din moment ce se mentioneaza in datele problemei ca se vor elimina țări, până când numărul lor devine cea mai mare putere a lui 2 posibilă, am aflat mai intai care este cea mai mare putere posibila, impartind numarul la 2 (deoarece voiam sa aflu puterea lui 2). Apoi, am calculat cate tari vor ramane in competitie, inmultind cu 2 pana se epuizeaza puterea. Astfel, numarul de tari sterse reprezinta diferenta dintre numarul initial de tari si cel al statelor ramase.
	Intrucat se doreste eliminarea tarilor care au scorul initial minim (se vor elimina atatea tari cate ne va spune functia mentionata mai sus) am creat o functie care sa determine scorul initial al fiecarei tari. Asadar, atunci cand citesc cate o tara din fisier ii voi calcula si scorul initial. Apoi, il voi introduce intr-o lista dublu inlantuita (cu santinela si circulara) de scoruri. Aceasta actiune are loc concomitent cu inserarea tarilor. Astfel, tara din lista head va avea aceeasi pozitie cu scorul specific din lista de scoruri. Asadar, ma folosesc de aceasta proprietate pentru a sterge tarile cu scorul initial minim.(Dupa aceasta operatiune afisez numele tarilor ramase in competitie in fisier.)
	Pentru a rezolva cerinta 3 am introdus toate tarile ramase in competitie intr-o stiva (stackTop). Am creat o functie tara_castig prin care aflu si adaug tarile ramase in competitie in stiva WINNER, dar prin care aflu si numarul de tari din stiva mentionata anterior (rezultatul e returnat de functie). De aceea, ii transmit stiva stackTop din care scot cate doua tari (doar una din ele va ramane in competitie). Apoi, introduc jucatorii fiecarei tari intr-o coada de meciuri, astfel: mai intai primul jucator al primei tari si apoi toti jucatorii celei de-a doua tari. Procedeul se repeta pana cand voi introduce ultimul jucator al primei tari urmat de toti jucatorii celei de-a doua tari. Dupa ce se termina inserarea jucatorilor in coada de meciuri, scot cate doi jucatori care se vor confrunta. Astfel, fiecare jucator al primei tari joaca cu fiecare jucator al celei de-a doua tari. In urma competitiei dintre (cei doi) jucatori fiecare va primi un anumit numar de puncte la scorul personal, dar si la scorul local al tarii din care fac parte (este valabil pentru confruntarea dintre cele doua tari) in cazul in care este egalitate, iar daca avem un castigator doar acesta si tara din care face parte vor primi puncte. Procedeul se repeta pana se elibereaza coada de meciuri.Scorul local obtinut in urma meciurilor dintre jucatori este adaugat la scorul global.
	Dupa aceasta actiune se pune in stiva WINNER doar tara care are scorul local mai mare. Daca e egalitate, determin jucatorul care are cel mai mare scor personal din fiecare tara si apoi compar scorurile celor doi, urmand sa adaug tara cu cel mai mare scor personal. Daca si de aceasta data este egalitate, adaug in stiva WINNER prima tara scoasa din stiva stackTop.
	Cresc contorul (cu 1) dupa ce am adaugat o tara. El determina cate tari sunt in stiva WINNER (returnez numarul de tari aflate in stiva WINNER). Procedeul se repeta pana cand in stiva nu mai ramane nicio tara, insemnand ca aceasta etapa a concursului s-a terminat. Numarul etapei e transmis prin parametru. Fiecare tara porneste (etapa 1) cu scorul global 0. 
	Ma intorc in main si scot cate o tara din stiva WINNER pe care o introduc in stiva stackTop (care acum e goala) pana cand se goleste stiva WINNER. Acum in stiva stackTop se afla tarile ramase in competitie, urmand ca procesul sa se repete pana cand in stiva WINNER ramane o singura tara, cea castigatoare. Dupa aceasta actiune nu mai am nevoie de cele doua stive, asa ca eliberez memoria ocupata de ele.
	Pentru rezolvarea cerintei 4, mi-am creat o lista dublu inlantuita (necirculara si fara santinela) in care am adaugat toate tarile RAMASE in competitie,astfel: mai intai am adaugat toate tarile care se confrunta, apoi tarile din stiva WINNER din fiecare etapa a competitiei, adaugandu-le la inceput. Astfel, in aceasta lista se afla tarile in urmatoarea ordine: in capul listei se afla tara castigatoare in urma confruntarilor, urmata de celelalte tari care s-au aflat in stiva WINNER in ordine descrescatoare a etapelor competitiei. Apoi, se gaseste in lista tarile din lista cu tarile ramase in competitie (head).
	Astfel, voi adauga intr-o coada jucatorii primelor patru tari distincte din lista. Pentru a afla care sunt aceste tari mi-am creat o functie care imi sterge toate tarile din listă care au acelasi nume cu cea stocata in capul listei. Bineinteles, am salvat inainte tara intr-o variabila locala, in main. De asemenea, am adaugat jucatorii corespunzatori tarii intr-o coada. Procedeul se repeta pana cand in coada se vor afla jucătorii ultimelor 4 țări rămase în turneu, în funcție de scorul personal obținut o dată cu terminarea ultimei etape a turneului. 
	Ulterior, scot cate un jucator din coada pana cand aceasta devine goala. Jucatorul scos este adaugat intr-un arbore binar de cautare, asta insemnand ca daca am parcurge arborele in inordine valorile ar fi afisate in ordine crescatoare in functie de scor (in subarborele stang se afla jucatorul care are scorul mai mic decat cel din radacina curenta, iar in subarborele drept se afla cel care are scorul mai mare decat cel din radacina curenta). Daca identificam in arbore un jucator care are acelasi scor cu al celui pe care dorim sa-l introducem le comparam numele pentru a afla care e mai mic din punct de vedere lexicografic, iar daca si de aceasta data avem egalitate le comparam prenumele (ma folosesc de strcmp). Dupa acest procedeu nu mai am nevoie de coada, asa ca eliberez memoria ocupata de ea.
	Pentru rezolvarea cerintei 5 am citit din fisierul "cerinte.in" datele despre cei doi jucatori ce servesc drept "chei" pentru identificarea numarului de jucatori aflati intre ei, adica ai celor care au scorul cuprins intre scorurile celor doi jucatori. Astfel, mi-am creat doua functii. Una care determina cheia pe care se afla un jucator dat intr-un arbore binar de cautare si o alta functie care se foloseste de cea specificata anterior pentru a numara jucatorii dintre cele doua "chei" date ca parametru (cei doi jucatori).
	In prima functie ma folosesc de o stiva pentru a afla cheia. Ea cauta (si gaseste) in stiva o valoare care sa aiba acelasi nume,prenume si scor cu al celui pe care il dam ca parametru si ii calculeaza "cheia". Daca o gaseste returneaza "cheia", altfel continua cautarea pana cand o gaseste. Daca totusi nu se intampla acest lucru functia va returna -1.
	In cea de-a doua functie ma folosesc de cea enuntata anterior pentru a afla cheia pe care se afla fiecare jucator transmis ca parametru. Daca cheia este -1 returnez o valoare specifica fiecarui jucator pentru a putea afisa din main un mesaj corespunzator. In caz contrar, introduc valorile arborelui intr-o stiva si incep cautarea, respectiv contorizarea elementelor care se afla intre cele doua chei. In final, eliberez memoria ocupata de stiva si returnez numarul de jucatori aflati intre cei doi. Asadar, in functie de rezultatul returnat de functia "interval" afisez in fisier un raspuns corespunzator.
	In final, eliberez memoria ocupata de arbore, lista de scoruri, lista ce contine TOATE tarile, cea de tari ramase in competitie, dar si alte variabile ce ocupau memoria. De asemenea, inchid si fisierele utilizate.                                               
	
